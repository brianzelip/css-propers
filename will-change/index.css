.will-change--auto: { will-change: auto; }
.will-change--scroll-position: { will-change: scroll-position; }
.will-change--contents: { will-change: contents; }
.will-change--inherit: { will-change: inherit; }
.will-change--initial: { will-change: initial; }
.will-change--unset: { will-change: unset; }

/*

Syntax
/* Keyword values */
/*will-change: auto;
will-change: scroll-position;
will-change: contents;
will-change: transform;        /* Example of <custom-ident> */
/*will-change: opacity;          /* Example of <custom-ident> */
/*will-change: left, top;        /* Example of two <animateable-feature> */

/* Global values */
/*will-change: inherit;
will-change: initial;
will-change: unset;
Values

auto
This keyword expresses no particular intent; the user agent should apply whatever heuristics and optimizations it normally does.
The <animateable-feature> can be one of the following values:

scroll-position
Indicates that the author expects to animate or change the scroll position of the element in the near future.
contents
Indicates that the author expects to animate or change something about the elementâ€™s contents in the near future.
<custom-ident>
Indicates that the author expects to animate or change the property with the given name on the element in the near future. If the property given is a shorthand, it indicates the expectation for all the longhands the shorthand expands to. It cannot be one of the following values: unset, initial, inherit, will-change, auto, scroll-position, or contents. The spec doesn't define the behavior of particular value, but it is common for transform to be a compositing layer hint. Chrome currently takes two actions, given particular css property idents: establish a new compositing layer or a new stacking context.
Formal syntax

auto | <animateable-feature>#
where
<animateable-feature> = scroll-position | contents | <custom-ident>

*/
